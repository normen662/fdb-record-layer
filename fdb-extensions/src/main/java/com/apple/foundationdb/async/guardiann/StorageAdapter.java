/*
 * StorageAdapter.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2025 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.async.guardiann;

import com.apple.foundationdb.async.common.StorageHelpers;
import com.apple.foundationdb.async.common.StorageTransform;
import com.apple.foundationdb.async.hnsw.HNSW;
import com.apple.foundationdb.linear.Quantizer;
import com.apple.foundationdb.linear.RealVector;
import com.apple.foundationdb.linear.Transformed;
import com.apple.foundationdb.subspace.Subspace;
import com.apple.foundationdb.tuple.Tuple;
import com.google.common.base.Suppliers;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nonnull;
import java.util.function.Supplier;

/**
 * TODO.
 */
class StorageAdapter {
    @Nonnull
    private static final Logger logger = LoggerFactory.getLogger(StorageAdapter.class);

    /**
     * Subspace for the access info.
     */
    private static final long SUBSPACE_PREFIX_ACCESS_INFO = 0x00;

    /**
     * Subspace for the cluster data, that is the centroids currently in use.
     */
    private static final long SUBSPACE_PREFIX_CLUSTER_CENTROIDS = 0x01;

    /**
     * Subspace for the cluster data, that is the centroids currently in use.
     */
    private static final long SUBSPACE_PREFIX_CLUSTER_INFOS = 0x02;

    /**
     * Subspace for the vector entries.
     */
    private static final long SUBSPACE_PREFIX_VECTOR_REFERENCES = 0x03;

    /**
     * Subspace for the vector entries.
     */
    private static final long SUBSPACE_PREFIX_VECTOR_IDS = 0x04;

    /**
     * Subspace for (mostly) statistical analysis (like finding a centroid, etc.). Contains samples of vectors.
     */
    private static final long SUBSPACE_PREFIX_SAMPLES = 0x05;

    /**
     * Subspace for outstanding tasks.
     */
    private static final long SUBSPACE_PREFIX_TASKS = 0x06;

    @Nonnull
    private final Config config;
    @Nonnull
    private final Subspace subspace;
    @Nonnull
    private final OnWriteListener onWriteListener;
    @Nonnull
    private final OnReadListener onReadListener;

    @Nonnull
    private final Supplier<Subspace> accessInfoSubspaceSupplier;
    @Nonnull
    private final Supplier<Subspace> clusterCentroidsSubspaceSupplier;
    @Nonnull
    private final Supplier<Subspace> clusterInfosSubspaceSupplier;
    @Nonnull
    private final Supplier<Subspace> vectorReferencesSubspaceSupplier;
    @Nonnull
    private final Supplier<Subspace> vectorIdsSubspaceSupplier;
    @Nonnull
    private final Supplier<Subspace> samplesSubspaceSupplier;
    @Nonnull
    private final Supplier<Subspace> tasksSubspaceSupplier;

    @Nonnull
    private final Supplier<com.apple.foundationdb.async.hnsw.Config> clusterCentroidsHnswConfigSupplier;

    /**
     * Constructs a new {@code StorageAdapter}.
     * <p>
     * This constructor initializes the adapter with the necessary configuration,
     * factories, and listeners for managing a guardian structure. It also sets up a
     * dedicated data subspace within the provided main subspace for storing node data.
     *
     * @param config the HNSW graph configuration
     * @param subspace the primary subspace for storing all graph-related data
     * @param onWriteListener the listener to be called on write operations
     * @param onReadListener the listener to be called on read operations
     */
    StorageAdapter(@Nonnull final Config config,
                   @Nonnull final Subspace subspace,
                   @Nonnull final OnWriteListener onWriteListener,
                   @Nonnull final OnReadListener onReadListener) {
        this.config = config;
        this.subspace = subspace;
        this.onWriteListener = onWriteListener;
        this.onReadListener = onReadListener;
        this.accessInfoSubspaceSupplier =
                Suppliers.memoize(() -> subspace.subspace(Tuple.from(SUBSPACE_PREFIX_ACCESS_INFO)));
        this.clusterCentroidsSubspaceSupplier =
                Suppliers.memoize(() -> subspace.subspace(Tuple.from(SUBSPACE_PREFIX_CLUSTER_CENTROIDS)));
        this.clusterInfosSubspaceSupplier =
                Suppliers.memoize(() -> subspace.subspace(Tuple.from(SUBSPACE_PREFIX_CLUSTER_INFOS)));
        this.vectorReferencesSubspaceSupplier =
                Suppliers.memoize(() -> subspace.subspace(Tuple.from(SUBSPACE_PREFIX_VECTOR_REFERENCES)));
        this.vectorIdsSubspaceSupplier =
                Suppliers.memoize(() -> subspace.subspace(Tuple.from(SUBSPACE_PREFIX_VECTOR_IDS)));
        this.samplesSubspaceSupplier =
                Suppliers.memoize(() -> subspace.subspace(Tuple.from(SUBSPACE_PREFIX_SAMPLES)));
        this.tasksSubspaceSupplier =
                Suppliers.memoize(() -> subspace.subspace(Tuple.from(SUBSPACE_PREFIX_TASKS)));

        this.clusterCentroidsHnswConfigSupplier = Suppliers.memoize(this::computeClusterCentroidHnswConfig);
    }

    @Nonnull
    Config getConfig() {
        return config;
    }

    @Nonnull
    Subspace getSubspace() {
        return subspace;
    }

    @Nonnull
    public Subspace getAccessInfoSubspace() {
        return accessInfoSubspaceSupplier.get();
    }

    @Nonnull
    Subspace getClusterCentroidsSubspace() {
        return clusterCentroidsSubspaceSupplier.get();
    }

    @Nonnull
    public Subspace getClusterInfosSubspace() {
        return clusterInfosSubspaceSupplier.get();
    }

    @Nonnull
    public Subspace getVectorReferencesSubspace() {
        return vectorReferencesSubspaceSupplier.get();
    }

    @Nonnull
    public Subspace getVectorIdsSubspace() {
        return vectorIdsSubspaceSupplier.get();
    }

    @Nonnull
    public Subspace getSamplesSubspace() {
        return samplesSubspaceSupplier.get();
    }

    @Nonnull
    public Subspace getTasksSubspace() {
        return tasksSubspaceSupplier.get();
    }

    @Nonnull
    OnWriteListener getOnWriteListener() {
        return onWriteListener;
    }

    @Nonnull
    OnReadListener getOnReadListener() {
        return onReadListener;
    }

    @Nonnull
    com.apple.foundationdb.async.hnsw.Config getClusterCentroidsHnswConfig() {
        return clusterCentroidsHnswConfigSupplier.get();
    }

    @Nonnull
    private com.apple.foundationdb.async.hnsw.Config computeClusterCentroidHnswConfig() {
        final Config config = getConfig();
        return HNSW.newConfigBuilder()
                .setMetric(config.getMetric())
                .setUseInlining(false)
                .setEfRepair(64)
                .setExtendCandidates(false)
                .setKeepPrunedConnections(false)
                .setUseRaBitQ(false)
                .setM(32)
                .setMMax(48)
                .setMMax0(64)
                .build(config.getNumDimensions());
    }

    @Nonnull
    static AccessInfo accessInfoFromTuple(@Nonnull final Config config, @Nonnull final Tuple valueTuple) {
        final long rotatorSeed = valueTuple.getLong(0);
        final Tuple centroidVectorTuple = valueTuple.getNestedTuple(1);
        return new AccessInfo(rotatorSeed,
                centroidVectorTuple == null ? null : StorageHelpers.vectorFromTuple(config, centroidVectorTuple));
    }

    @Nonnull
    static Tuple tupleFromAccessInfo(@Nonnull final AccessInfo accessInfo) {
        final RealVector centroid = accessInfo.getNegatedCentroid();
        return Tuple.from(accessInfo.getRotatorSeed(),
                centroid == null ? null : StorageHelpers.tupleFromVector(centroid));
    }

    @Nonnull
    static VectorId vectorIdFromTuple(@Nonnull final Tuple primaryKey, @Nonnull final Tuple valueTuple) {
        return new VectorId(primaryKey, valueTuple.getUUID(0));
    }

    @Nonnull
    static Tuple valueTupleFromVectorId(@Nonnull final VectorId vectorId) {
        return Tuple.from(vectorId.getUuid());
    }

    @Nonnull
    static ClusterInfo clusterInfoFromTuple(@Nonnull final Tuple valueTuple) {
        return new ClusterInfo(valueTuple.getUUID(0), Math.toIntExact(valueTuple.getLong(1)),
                Math.toIntExact(valueTuple.getLong(2)));
    }

    @Nonnull
    static Tuple valueTupleFromClusterInfo(@Nonnull final ClusterInfo clusterInfo) {
        return Tuple.from(clusterInfo.getUuid(), clusterInfo.getNumVectors(), clusterInfo.getState().getCode());
    }

    @Nonnull
    static VectorReference vectorReferenceFromTuples(@Nonnull final Config config,
                                                     @Nonnull final StorageTransform storageTransform,
                                                     @Nonnull final Tuple primaryKey,
                                                     @Nonnull final Tuple valueTuple) {
        final VectorId vectorId = new VectorId(primaryKey, valueTuple.getUUID(0));
        return new VectorReference(vectorId,
                storageTransform.transform(StorageHelpers.vectorFromBytes(config, valueTuple.getBytes(1))));
    }

    @Nonnull
    static Tuple valueTupleFromVectorReference(@Nonnull final Quantizer quantizer,
                                               @Nonnull final VectorReference vectorReference) {
        final VectorId vectorId = vectorReference.getId();
        final Transformed<RealVector> encodedVector = quantizer.encode(vectorReference.getVector());
        return Tuple.from(vectorId.getUuid(), encodedVector.getUnderlyingVector().getRawData());
    }
}
